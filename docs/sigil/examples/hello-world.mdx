---
sidebar_position: 1
title: 1. Hello World
---

This example illustrates the fundamental structure of a simple Sigil contract, serving as a good starting point for creating your own.

<Note>
**Full working code**: The complete source code for this example is available in [`example-contracts/hello-world/`](https://github.com/KontorProtocol/Documentation/tree/main/example-contracts/hello-world)
</Note>

## WIT Interface
- Includes `kontor:built-in` via the `wit/deps/built-in.wit` symlink
- Exports:
  - `init`: All contracts must implement an `init` function which will be run automatically at publication
  - `hello-world`: A simple view function that returns a string

```wit contract/wit/contract.wit
package kontor:contract;

world contract {
    include kontor:built-in/built-in;
    use kontor:built-in/context.{view-context, proc-context};

    export init: func(ctx: borrow<proc-context>);

    export hello-world: func(ctx: borrow<view-context>) -> string;
}
```

## Rust Implementation
In `contract/src/lib.rs`, the `contract!` sets the contract name and generates boilerplate code and types. The `HelloWorld` struct is automatically derived from it. The generated `Guest` trait is implemented with:
- `init`: Empty, as no contract storage is needed
- `hello-world`: Returns a static string

```rust contract/src/lib.rs
use stdlib::*;

contract!(name = "hello-world");

impl Guest for HelloWorld {
    fn init(_ctx: &ProcContext) {}

    fn hello_world(_ctx: &ViewContext) -> String {
        "Hello, World!".to_string()
    }
}
```

## Testing
The test in `test/src/lib.rs`:
- The `use testlib::*` import populates the namespace with trait implementations and types to make testing contracts as close to calling Rust functions as possible.
- `contract_bytes()` loads the bytes of the `hello-world` contract.
- `import!` generates a module named `hello_world` (the snake case version of the `name` `hello-world`) that exposes functions matching the contract's exports, providing a convenient interface for interacting with it.
- Calls `hello_world`, and verifies the output.

```rust test/src/lib.rs
#[cfg(test)]
mod tests {
    use testlib::*;

    import!(
        name = "hello-world",
        height = 0,
        tx_index = 0,
        path = "contract/wit",
    );

    #[tokio::test]
    async fn test_contract() -> Result<()> {
        let runtime = Runtime::new(
            RuntimeConfig::builder()
                .contracts(&[("hello-world", &contract_bytes().await?)])
                .build(),
        )
        .await?;

        let result = hello_world::hello_world(&runtime).await?;
        assert_eq!(result, "Hello, World!");

        Ok(())
    }
}
```
