---
sidebar_position: 3
title: Getting Started
---

This guide walks you through setting up your development environment and creating your first Sigil smart contract—a simple counter that demonstrates the fundamentals.

## Setup

### Install Dependencies

#### MacOS
Install `binaryen` and `brotli` using Homebrew:
```bash
brew install binaryen brotli
```

#### Debian
Install `binaryen` and `brotli`:
```bash
sudo apt install binaryen brotli
```

### Set Up Rust
Sigil is built with Rust, so you need the latest stable Rust version installed.

1. Install Rust by following the instructions at [https://www.rust-lang.org/tools/install](https://www.rust-lang.org/tools/install) or update to the latest stable version.
2. Add the WebAssembly target for compiling Sigil contracts:
   ```bash
   rustup target add wasm32-unknown-unknown
   ```

## Create Your Counter Contract

**Project structure:**
```
my-counter/
├── Cargo.toml
├── wit/
│   └── contract.wit
└── src/
    └── lib.rs
```

### Step 1: Configure Cargo.toml

```toml
[package]
name = "counter"
version = "0.1.0"
edition = "2024"

[dependencies]
wit-bindgen = "=0.47.0"
stdlib = { path = "../core/stdlib" }

[lib]
crate-type = ["cdylib"]
```

**Key points:**
- `crate-type = ["cdylib"]` - Builds a dynamic library for WASM
- `wit-bindgen` version must be exactly `0.47.0`
- `stdlib` provides Sigil macros and runtime primitives

### Step 2: Define Contract Interface (WIT)

Create `wit/contract.wit`:

```wit
package root:component;

world root {
  include kontor:built-in/built-in;
  use kontor:built-in/context.{view-context, proc-context};

  export init: func(ctx: borrow<proc-context>);
  export increment: func(ctx: borrow<proc-context>);
  export get: func(ctx: borrow<view-context>) -> u64;
}
```

**What this defines:**
- `init` - Called once when contract is deployed (writes state)
- `increment` - Increases the counter (writes state)
- `get` - Returns current count (read-only)

### Step 3: Implement Contract Logic

Create `src/lib.rs`:

```rust
use stdlib::*;

contract!(name = "counter");

#[derive(Clone, Default, StorageRoot)]
struct CounterStorage {
    pub count: u64,
}

impl Guest for Counter {
    fn init(ctx: &ProcContext) {
        CounterStorage::default().init(ctx);
    }

    fn increment(ctx: &ProcContext) {
        let current = ctx.model().count();
        ctx.model().set_count(current + 1);
    }

    fn get(ctx: &ViewContext) -> u64 {
        ctx.model().count()
    }
}
```

**How it works:**
- `contract!(name = "counter")` - Generates the `Guest` trait and WASM bindings
- `#[derive(StorageRoot)]` - Generates storage accessors (`count()`, `set_count()`)
- `ctx.model()` - Provides typed access to storage
- `init()` - Sets initial count to 0
- `increment()` - Reads current value, increments, writes back
- `get()` - Returns current value

### Step 4: Build the Contract

```bash
cargo build --release --target wasm32-unknown-unknown
```

**Output:** `target/wasm32-unknown-unknown/release/counter.wasm`

**For optimized builds** (recommended), create `build.sh`:

```bash
#!/bin/bash
set -e

cargo build --release
cd target/wasm32-unknown-unknown/release

# Optimize
wasm-opt -Oz --enable-bulk-memory --enable-sign-ext counter.wasm -o counter_opt.wasm

# Compress
brotli -Zf counter_opt.wasm -o counter.wasm.br
```

Then:
```bash
chmod +x build.sh
./build.sh
```

### Step 5: Write Tests

Create `test/src/lib.rs`:

```rust
#[cfg(test)]
mod tests {
    use testlib::*;

    interface!(name = "counter", path = "contract/wit");

    #[testlib::test]
    async fn test_counter() -> Result<()> {
        // Create a test user
        let alice = runtime.identity().await?;
        
        // Deploy the counter contract
        let counter = runtime.publish(&alice, "counter").await?;
        
        // Initial value should be 0
        let value = counter::get(runtime, &counter).await?;
        assert_eq!(value, 0);
        
        // Increment
        counter::increment(runtime, &counter, &alice).await?;
        
        // Value should now be 1
        let value = counter::get(runtime, &counter).await?;
        assert_eq!(value, 1);
        
        // Increment again
        counter::increment(runtime, &counter, &alice).await?;
        
        let value = counter::get(runtime, &counter).await?;
        assert_eq!(value, 2);
        
        Ok(())
    }
}
```

**Run tests:**
```bash
cd test
cargo test
```

## Common First-Time Errors

**`contract!` macro not found**
```
error: cannot find macro `contract` in this scope
```
**Solution:** Add `use stdlib::*;` at the top of your file

**Missing Guest trait implementation**
```
error: not all trait items implemented, missing: `increment`
```
**Solution:** Ensure you've implemented all functions listed in your WIT file

**WIT file parse error**
```
error: expected `include`, `use`, `import`, `export`, or `type`
```
**Solution:** Ensure you have `include kontor:built-in/built-in;` in your WIT world

**Build fails with missing symbols**
```
error: linking with `rust-lld` failed
```
**Solution:** Check that `wit-bindgen` version is exactly `0.47.0`