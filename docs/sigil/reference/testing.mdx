---
sidebar_position: 2
title: Testing
---

# Testing Environment Reference

## Runtime

The test runtime is automatically injected via the `#[testlib::test]` attribute. It provides methods for managing test execution:

### `runtime.identity() -> Result<Signer>`

Creates a new test identity (user) with automatic gas funding.

### `runtime.publish(&signer, "name") -> Result<ContractAddress>`

Deploys a contract from compiled bytecode and returns its address.

### `runtime.wit(&contract_address) -> Result<String>`

Retrieves the WIT interface of a deployed contract.

## Test Attribute

Use `#[testlib::test]` to mark async test functions:

```rust
#[testlib::test]
async fn my_test() -> Result<()> {
    // 'runtime' is auto-injected
    let alice = runtime.identity().await?;
    let contract = runtime.publish(&alice, "my-contract").await?;
    // ... test code
    Ok(())
}
```

For integration tests against Bitcoin regtest:

```rust
#[testlib::test(mode = "regtest")]
async fn my_integration_test() -> Result<()> {
    // ... test code
}
```

## Interface Macro

Generates type-safe bindings for contract calls:

```rust
interface!(name = "token", path = "contract/wit");
```

Generated functions are async and take `runtime`, `contract_address`, and `signer` parameters:

```rust
token::mint(runtime, &token_address, &signer, amount).await??;
```

For tests, use `interface!` which generates bindings for any contract address. The `import!` macro (for fixed addresses) is rarely needed in tests.
